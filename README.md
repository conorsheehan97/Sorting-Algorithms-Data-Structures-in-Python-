# Sorting-Algorithms-Data-Structures-in-Python-
## Overview
This project explores various sorting algorithms including Bubble Sort, Merge Sort, Selection Sort, Insertion Sort, Quick Sort, and Heap Sort. Additionally, it implements essential data structures such as Binary Trees, Hash Tables, Stacks, Queues, and Linked Lists in Python. Each algorithm and data structure is implemented with detailed explanations and runtime complexity analysis.

## Sorting Algorithms
### Bubble Sort
 - Description: Simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
 - Implementation: Python function implementing Bubble Sort with optimizations.
 - Runtime Complexity: O(n^2) in worst and average cases.
### Merge Sort
 - Description: Divide and conquer algorithm that divides the input array into two halves, recursively sorts each half, and then merges the sorted halves.
 - Implementation: Python function implementing Merge Sort using recursion.
 - Runtime Complexity: O(n log n) in all cases.
### Selection Sort
 - Description: In-place comparison-based sorting algorithm that divides the input list into a sorted and an unsorted region, repeatedly selects the smallest element from the unsorted region and swaps it with the leftmost unsorted element.
 - Implementation: Python function implementing Selection Sort.
 - Runtime Complexity: O(n^2) in all cases.
### Insertion Sort
 - Description: Simple sorting algorithm that builds the final sorted array one item at a time, inserting each item into its correct position.
 - Implementation: Python function implementing Insertion Sort.
 - Runtime Complexity: O(n^2) in worst case, O(n) in best case.
### Quick Sort
 - Description: Divide and conquer algorithm that selects a 'pivot' element and partitions the array around the pivot, recursively sorting each partition.
 - Implementation: Python function implementing Quick Sort using recursion.
 - Runtime Complexity: O(n log n) in average case, O(n^2) in worst case.
### Heap Sort
 - Description: Comparison-based sorting algorithm that uses a binary heap data structure. It repeatedly removes the largest element from the heap and rebuilds the heap until all elements have been removed.
 - Implementation: Python function implementing Heap Sort.
 - Runtime Complexity: O(n log n) in all cases.
## Data Structures
### Binary Trees
 - Description: Tree data structure in which each node has at most two children, referred to as the left child and the right child.
 - Implementation: Python class implementing Binary Tree with methods for insertion, deletion, traversal, and search operations.
 - Runtime Complexity: Depends on the operation, generally O(log n) for balanced trees.
### Hash Tables
 - Description: Data structure that implements an associative array abstract data type, a structure that can map keys to values.
 - Implementation: Python class implementing Hash Table with methods for key-value pair operations and handling collisions.
 - Runtime Complexity: O(1) average time complexity for insert and lookup operations, assuming a good hash function.
### Stacks
 - Description: Abstract data type that serves as a collection of elements with two main operations: push, which adds an element to the collection, and pop, which removes the most recently added element.
 - Implementation: Python class implementing Stack with methods for push, pop, peek, and isEmpty operations.
 - Runtime Complexity: O(1) for push, pop, peek operations.
### Queues
 - Description: Abstract data type that follows the First In First Out (FIFO) principle, where elements are added to the rear (enqueue) and removed from the front (dequeue).
 - Implementation: Python class implementing Queue with methods for enqueue, dequeue, peek, and isEmpty operations.
 - Runtime Complexity: O(1) for enqueue, dequeue, peek operations.
### Linked Lists
 - Description: Linear data structure where each element is a separate object (node) containing a pointer to the next node in the sequence.
 - Implementation: Python class implementing Linked List with methods for insertion, deletion, traversal, and search operations.
 - Runtime Complexity: Depends on the operation, generally O(1) for insertion and deletion at the head, O(n) for traversal and search.
## Usage
 - Explore and understand each sorting algorithm and data structure by reviewing their implementations and runtime complexities.
 - Modify and extend implementations as needed for specific applications or optimizations.
 - Use examples and test cases provided in the code to verify functionalities and performance.
## Conclusion
This project serves as a comprehensive guide to sorting algorithms and fundamental data structures in Python. By implementing and analyzing each algorithm and structure, it provides insights into algorithmic efficiency and practical application scenarios.

Contributions and feedback are welcome to enhance the functionality and expand the capabilities of this project.
